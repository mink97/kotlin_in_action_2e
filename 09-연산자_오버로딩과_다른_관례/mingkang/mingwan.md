# 9. 연산자 오버로딩과 다른 관례

- **관례**: 어떤 언어 기능과 미리 정해진 이름의 함수를 연결해주는 기법
- 코틀린은 관례에 의존
- 기존 자바 클래스에 대해 확장 함수를 구현하면서 관례에 따라 이름을 붙이면 기존 자바 코드를 바꾸지 않아도 새로운 기능을 쉽게 부여 가능

## 9.1 산술 연산자 오버로드
### 9.1.1 plus, times, divide 등: 이항 산술 연산 오버로딩
- plus 연산자 구현
  - `operator fun plus(other: Point): Point`
  - `plus`함수 앞에 `operator`키워드를 붙여야 함.
    - 연산자를 오버로딩하는 함수 앞에는 반드시 `operator`가 있어야 함. 관례를 따르는 함수임을 명확히 함.
  - `plus` 함수를 선언하고 나면 `+`기호로 두 Point 객체를 더할 수 있음.
- 연산자를 확장함수로 정의할 수도 있음
  ```kotlin
  operator fun Point.plus(other: Point): Point {
    return Point(x + other.x, y + other.y)
  }
  ```
- 두 피연산자 사이에 함수를 호출하고 싶은 경우 코틀린은 중위 함수 제공(ex. a to b)
- 코틀린에서는 프로그래머가 직접 연산자를 만들어 사용할 수 없고 언어에서 미리 정해둔 연산자만 오버로딩할 수 있으며,<br/>
  관례에 따르기 위해 클래스에서 정의해야 하는 이름이 연산자별로 정해져 있다.<br/>
![image](https://github.com/user-attachments/assets/1c8f9623-8a68-4347-9049-e43a5acc8a09)
- 연산자를 정의할 때 두 피연산자가 같은 타입일 필요는 없음.
- 연산자 함수의 반환 타입이 꼭 두 피연산자 중 하나와 일치해야만 하는 것도 아님.
  ```kotlin
  operator fun Char.times(count: Int) = toString().repeat(count)

  fun main() {
    println('a' * 3)
    // aaa
  }
  ```
- 코틀린 연산자가 자동으로 교환법칙을 지원하지는 않음.
- operator 함수도 오버로딩 할 수 있음. 이름은 같지만 파라미터 타입이 서로 다른 연산자 함수를 여럿 만들 수 있음.

> **비트 연산자에 대해 특별한 연산자 함수를 사용하지 않는다.**
> 코틀린은 표준 숫자 타입에 대해 비트 연산자를 정의하지 않는다.(커스텀 타입도 정의 불가)
> 대신 중위 연산자 표기법을 지원하는 일반 함수를 사용해 비트 연산을 수행
> - `shl`: 왼쪽 시프트(<<)
> - `shr`: 오른쪽 시프트(부호비트 유지, >>)
> - `ushr`: 오른쪽 시프트(0으로 부호비트 설정, >>>)
> - `and`: 비트 곱(&)
> - `or`: 비트 합(|)
> - `xor`: 비트 배타 합(^)
> - `inv`: 비트 반전(~)
> - 예시
>   ```kotlin
>   fun main() {
>     println(0x0F and 0xF0) // 0
>     println(0x0F or 0xF0) // 255
>     println(0x1 shl 4) // 16
>   }

### 9.1.2 연산을 적용한 다음에 그 결과를 바로 대입: 복합 대입 연산자 오버로딩
- plus와 같은 연산자를 오버로딩하면 코틀린은 +=(복합대입연산자)도 자동으로 함께 지원.
- 변수가 변경 가능한 경우에만 복합 대입 연산자 사용 가능
- +=연산이 객체에 대한 참조를 다른 참조로 바꾸기보다 원래 객체의 내부 상태를 변경하게 만들고 싶을 때가 있음. (ex. 변경 가능한 컬렉션에 원소를 추가하는 경우)
  - 반환 타입이 Unit인 plusAssign 함수를 정의하면서 operator로 표시하면 코틀린은 += 연산자에 그 함수를 사용
  - 그 외에 복합 대입 연산자 함수도 minusAssign, timesAssign 등의 이름 사용
- 코틀린 표준 라이브러리는 변경 가능한 컬렉션에 대해 plusAssign을 정의
  ```kotlin
  operator fun <T> MutableCollection<T>.plusAssign(element: T) {
    this.add(element)
  }
  ```
- plus와 plusAssign 연산을 동시에 정의하지 말라.
- 클래스가 앞에서 본 Point처럼 변경 불가능하다면 plus와 같이 새로운 값을 반환하는 연산만을 추가해야 함.
- 빌더와 같이 변경 가능한 클래스를 설계한다면 plusAssign이나 그와 비슷한 연산만을 제공하자.
- 코틀린 표준 라이브러리는 컬렉션에 대해 2가지 접근 방법을 함께 제공.
  - +와 -는 항상 새로운 컬렉션 반환.
  - +=와 -=는 항상 변경 사능한 컬렉션에 작용, 메모리에 있는 객체 상태를 변화시킴.
  - 읽기 전용 컬렉션에서 +=와 -=는 변경을 적용한 복사본 반환(var로 선언한 경우에만 적용가능)
 
### 9.1.3 피연산자 1개뿐인 연산자: 단항 연산자 오버로딩
- 단항 연산자를 오버로딩하기 위해 사용하는 함수는 인자를 취하지 않는다.<br/>
![image](https://github.com/user-attachments/assets/bdf61e1d-1b74-4318-bb12-020dff8cb3e6)

## 9.2 비교 연산자를 오버로딩해서 객체들 사이의 관계를 쉽게 검사
- 코틀린에서는 == 비교 연산자를 직접 사용할 수 있어 비교 코드가 `equals`나 `compareTo`를 사용한 코드보다 더 간결하며 이해하기 쉽다.

### 9.2.1 동등성 연산자: equals
- ==연산자 호출을 equals 메서로 호출로 컴파일
- !=연산자를 사용하는 식도 equals 호출로 컴파일. 비교 결과를 뒤집은 값을 결괏값으로 사용
- ==과 !=는 내부에서 인자가 null인지 검사하므로 다른 연산과 달리 nullable에도 적용가능<br/>
  ![image](https://github.com/user-attachments/assets/b83f1101-5030-42b8-965c-751c7c9ce3f9)
- equals를 구현할 때는 ===를 사용해 자신과의 비교를 최적화하는 경우가 많음.(===를 오버로딩 불가)
- **equals함수에는 override가 붙어있음. 다른 연산자 오버로딩 관례와 달리 equals는 Any에 정의된 메서드이므로 override필요**
- Any의 equals에는 operator가 붙어있지만 그 메서드를 오버라이드하는(하위 클래스) 메서드 앞에는 operator 변경자를 붙이지 않아도 <br/>
  자동으로 상위 클래스의 operator지정 적용.
- Any에서 상속받은 equals가 확장 함수보다 우선순위가 높기 때문에 equals를 확장 함수로 정의할 수는 없음.

### 9.2.2 순서 연산자: compareTo (<, >, <=, >=)
- 코틀린은 Comparable인터페이스 안에 있는 compareTo 메서드를 호출하는 관례를 제공, 비교연산자를 사용하는 코드를 compareTo호출로 컴파일<br/>
![image](https://github.com/user-attachments/assets/8f2353a8-1c3a-48b0-8647-496772862775)
- compareTo가 반환하는 값은 Int
- 

























